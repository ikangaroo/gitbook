{"./":{"url":"./","title":"前言","keywords":"","body":"前言 记录自己刷剑指Offer的过程，简单记录对于每个题的理解或者思考过程，有些题自己可以想到做出来，但不是很会给别人讲，所以两一方面也算是锻炼下自己的表述能力，目前由于时间原因，一些自己认为简单的题会一句话带过，以后有时间的话在回头进行完善 平台： 中文LeetCode 持续更新中..... "},"03.html":{"url":"03.html","title":"数组中重复的数字","keywords":"","body":"数组中重复的数字 问题描述： 找出数组中重复的数字 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 解题思路 字典法 使用 HashSet 或者 数组来记录已遍历的数字，如果找到重复的数字，则返回 时间复杂度：O(n)，空间复杂度：O(n)，需要额外空间 class Solution { public int findRepeatNumber(int[] nums) { // hashSet if (nums == null || nums.length == 0) return -1; int n = nums.length, ans = -1; int[] count = new int[n]; for (int num: nums) { if (count[num] != 0) { ans = num; break; } count[num]++; } return ans; // int[] if (nums == null || nums.length == 0) return -1; int ans = -1; Set set = new HashSet<>(); for (int num: nums) { if (!set.add(num)) { ans = num; break; } set.add(num); } return ans; } } 排序法 先排序，然后遍历数组，如果相邻元素相等，则返回 时间复杂度：O(nlogn)，空间复杂度：O(1)，不需要额外空间，修改输入数组 class Solution { public int findRepeatNumber(int[] nums) { // 排序 if (nums == null || nums.length == 0) return -1; int n = nums.length, ans = -1; Arrays.sort(nums); for (int i = 0; i 置换法 置换法，值为 x 的元素，置换到数组索引为 x 的位置。如果当前元素值等于索引值，则继续进行遍历，如果不相等，则将 nums[x] 置换到正确的位置上，即 nums[nums[x]]，如果在这个过程中，数组 nums[x] 索引下的值已经为 nums[nums[x]]，则说明 nums[x] 重复，返回即可 时间复杂度：O(n)，空间复杂度：O(1)，不需要额外空间，修改输入数组。虽然 for 循环里面套了 while，但是每一个数来到它应该在的位置以后，位置就不会再变化。这里用到的是均摊复杂度分析的方法：如果在某一个位置 while 循环体执行的次数较多，那么一定在后面的几个位置，根本不会执行 while 循环体内的代码，也就是说最坏的情况不会一直出现。也就是说最坏复杂度的情况不会一直出现。 class Solution { public int findRepeatNumber(int[] nums) { // 交换 if (nums == null || nums.length == 0) return -1; int n = nums.length, ans = -1; for (int i = 0; i 拓展 287. 寻找重复数 与上面题类似，但因为数组长度和数组元素限制的特点，解题思路不同 二分法 快慢指针法 文章分享 特别好用的二分查找法模板（第 2 版） [leetcode]灵魂画师图解&#x1F3A8;快慢指针在算法中的应用 "},"04.html":{"url":"04.html","title":"二维数组中的查找","keywords":"","body":"二维数组中的查找 问题描述： 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数 解题思路 观察法 观察题目数组中元素的特点，从右上角开始查找，如果相等则返回 true，如果小于 target，则在当前一行的下面进行搜索，如果大于 target，则在当前一列的左边进行搜索 时间复杂度：O(m+n)，空间复杂度：O(1) class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while (row = 0) { if (matrix[row][col] == target) return true; if (matrix[row][col] "},"05.html":{"url":"05.html","title":"替换空格","keywords":"","body":"替换空格 问题描述： 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\" 解题思路 API 时间复杂度：O(n)，空间复杂度：O(1) class Solution { public String replaceSpace(String s) { if (s == null || s.length() == 0) return \"\"; return s.replace(\" \", \"%20\"); } } StringBuilder 时间复杂度：O(n)，空间复杂度：O(n) class Solution { public String replaceSpace(String s) { if (s == null || s.length() == 0) return \"\"; StringBuilder sb = new StringBuilder(); for (char c: s.toCharArray()) { if (c == ' ') sb.append(\"%20\"); else sb.append(c); } return sb.toString(); } } 剑指Offer思路 只是为了加深下这种思路的影响，首先统计字符串中空格的数量，然后进行扩容，然后从后往前进行赋值，这样在线性时间内即可完成；如果输入参数为不可变的 String，就不能使用 setLength() 方法，所以用此方法效率会更慢（String 转为遍历 StringBuilder； setLength方法执行也很慢，其内部扩容主要调用 Arrays.copyOf() 和 Arrays.fill()） class Solution { public String replaceSpace(String s) { if (s == null || s.length() == 0) return \"\"; // 剑指Offer StringBuilder sb = new StringBuilder(s); int count = 0, oldLength = sb.length(); for (int i = 0; i = 0; --i) { char c = sb.charAt(i); if (c == ' ') { sb.setCharAt(idx--, '0'); sb.setCharAt(idx--, '2'); sb.setCharAt(idx--, '%'); } else { sb.setCharAt(idx--, c); } } return sb.toString(); } } 知识点 String、StringBuffer和StringBuilder的相似点与不同点： 运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder > StringBuffer > String；String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。 线程安全；在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的；如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。 String：适用于少量的字符串操作的情况；StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 "},"06.html":{"url":"06.html","title":"从尾到头打印链表","keywords":"","body":"从尾到头打印链表 题目描述： 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回） 解题思路 列表 + 反转法 遍历链表的同时，用列表保存其值，然后反转列表即可 时间复杂度：O(n)，空间复杂度：O(n) class Solution { public int[] reversePrint(ListNode head) { List l = new ArrayList<>(); while (head != null) { l.add(head.val); head = head.next; } Collections.reverse(l); return l.stream().mapToInt(Integer::valueOf).toArray(); } 栈 基本操作 时间复杂度：O(n)，空间复杂度：O(n) class Solution { public int[] reversePrint(ListNode head) { Deque stack = new ArrayDeque<>(); int count = 0; while (head != null) { count++; stack.push(head.val); head = head.next; } int idx = 0, ans[] = new int[count]; while (idx 反转链表法 将链表进行反转，然后遍历得到结果，如果需要的话，最后再将链表进行还原 时间复杂度：O(n)，空间复杂度：O(1) （不包含返回值 int[] 所占空间） class Solution { int count; public int[] reversePrint(ListNode head) { head = reverse(null, head, head); ListNode cur = head; int idx = 0, ans[] = new int[count]; while (cur != null) { ans[idx++] = cur.val; cur = cur.next; } head = reverse(null, head, head); return ans; } private ListNode reverse(ListNode pre, ListNode next, ListNode cur) { count = 0; while (cur != null) { count++; next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre; } } 知识点 List 调用 toArray(T[]) 方法转换为数组时，这里 T 代表泛型，泛型必须为引用类型。所以不能这样 list.toArray(new int[0])，但可以这样 list.toArray(new int[0][0])，因为 int[] 时引用类型。如果要将 list 转为维度为 (3, 2) 的数组，不需要这样 list.toArray(new int[3][2])，可以但没有必须，使用 list.toArray(new int[0][0]) 执行速度更快。详情看参考链接 Java 中一般使用 ArrayDeque 双向队列来模拟栈，而不用 Stack，原因大概有： Stack 继承于 Vector ，是 Java 早期的产物，里面有很多冗余的方法，使用不方便。且被遗弃，JAVA 官方也不推荐使用此类 很多方法都用了 synchronized 修饰符，虽然保证了线程安全，但效率会很低。一般场景下使用 ArrayDeque 即可，如果在需要保证线程安全时，使用 Collections.synchronizedCollection()将其转换为线程安全的即可 Collections.reverse(List list) 核心操作：以中心为轴，交换对称的元素 ListIterator fwd = list.listIterator(); ListIterator rev = list.listIterator(size); for (int i=0, mid=list.size()>>1; i 参考链接 List (或ArrayList) 转换为int[]数组 终于搞懂了 Java中List, Integer[], int[]的相互转换 You should use toArray(new T[0]) instead of toArray(new T[size]). /236259) Arrays of Wisdom of the Ancients "},"07.html":{"url":"07.html","title":"重建二叉树","keywords":"","body":"重建二叉树 问题描述： 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字 解题思路 递归法 先使用字典保存 前序遍历 数组中每个元素在 中序遍历 数组中对应的索引值，目的：空间换时间。大体思路：对于每个前序遍历数组中的元素 X，查字典得其对应得索引值 I，则其左子树的所有值在中序遍历数组中索引值为 I 的左边，右子树的所有元素在中序遍历数组中索引值为 I 的右边，递归建树即可 时间复杂度：O(n)，空间复杂度：O(n) class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) return null; Map map = new HashMap<>(); for (int i = 0; i map, int left, int right) { if (left > right) return null; TreeNode cur = new TreeNode(preorder[i]); int idx = map.get(preorder[i]); cur.left = helper(i + 1, preorder, map, left, idx - 1); // idx - left 表示以 cur 为根，其左子树的节点个数 cur.right = helper(i + idx - left + 1, preorder, map, idx + 1, right); return cur; } } "},"09.html":{"url":"09.html","title":"用两个栈实现队列","keywords":"","body":"用两个栈实现队列 题目描述： 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 解题思路 一个栈用于保存输入元素，并一个元素用于保存输出元素。队列末尾添加元素时，即向 in 栈中添加元素，当从队头删除元素时，将 in 栈中的元素出栈，每次先出栈元素 push 到 out 栈中，这样起到反转元素顺序的作用，此时对 out 栈进行 pop ，就相当于从对头删除元素 由于问题特殊，以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况 时间复杂度：appendTail()函数为 O(1)；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。 空间复杂度：O(N) class CQueue { Deque in; Deque out; public CQueue() { in = new ArrayDeque<>(); out = new ArrayDeque<>(); } public void appendTail(int value) { in.push(value); } public int deleteHead() { if (in.isEmpty() && out.isEmpty()) return -1 ; if (out.isEmpty()) { while(!in.isEmpty()) { out.push(in.pop()); } } return out.pop(); } } "},"10-1.html":{"url":"10-1.html","title":"斐波那契数列","keywords":"","body":"斐波那契数列 问题描述： 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 解题思路 动态规划 根据斐波那契数列的特点，用递归的思路即可 时间复杂度：O(n)，空间复杂度：O(1) class Solution { public int fib(int n) { int first = 0, second = 1, Mod = 1_000_000_007; for (int i = 0; i 拓展 此类题目（动态规划）的解题思路： DFS （top-down） DFS + Memorization （top-down） DP （down-top） N Variables （down-top） 参考链接 From good to great. How to approach most of DP problems. "},"10-2.html":{"url":"10-2.html","title":"青蛙跳台阶问题","keywords":"","body":"青蛙跳台阶问题 问题描述： 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 解题思路 动态规划 青蛙想到第 X 级台阶，只存在两种可能，从第 X-1 级台阶处跳1级，从第 X-2级台阶处跳2级。假设 f(x)表示青蛙跳到第 X 级台阶的总跳法，则其等于 f(x-1) + f(x-2)，其中 x >= 2，且 f(0) = 1, f(1) = 1 时间复杂度：O(n)，空间复杂度：O(1) class Solution { public int numWays(int n) { int first = 1, second = 1, Mod = 1_000_000_007; for (int i = 0; i "},"11.html":{"url":"11.html","title":"旋转数组中的最小数字","keywords":"","body":"旋转数组的最小数字 题目描述： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 解题思路 二分查找 根据数组的特点，利用二分法来做，每次取中间值 numbers[mid]，分三种情况进行讨论： numbers[mid] > numbers[right]，此时说明旋转的部分在 mid 右侧 numbers[mid] ，此时说明 mid 右边一定不包含最小值，numbers[mid] 有可能是，也有可能在 mid 左侧 numbers[mid] == numbers[right]，此时不能确定最小值在 m 的哪一侧，但可以确定的是，把 numbers[right] 舍弃掉，并不影响结果 Case 1：[1, 0, 1, 1, 1]，最小值在 mid = 2 的左侧 Case 2：[1, 1, 1, 0, 1]，最小值在 mid = 2 的右侧 时间复杂度：O(logn)，空间复杂度：O(1) class Solution { public int minArray(int[] numbers) { int left = 0, right = numbers.length - 1; while (left > 1; int mid = ((left + right) >>> 1); if (numbers[mid] > numbers[right]) { // 下一轮搜索区间是 [mid + 1, right] left = mid + 1; } else if (numbers[mid] "},"12.html":{"url":"12.html","title":"矩阵中的路径","keywords":"","body":"矩阵中的路径 题目描述： 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[\"a\",\"b\",\"c\",\"e\"], [\"s\",\"f\",\"c\",\"s\"], [\"a\",\"d\",\"e\",\"e\"]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子 解题思路 DFS + 回溯 常规题目，使用DFS进行递归求解，如果矩阵元素和当前目标字符相等，则继续递归求解，这个过程同时用 visited[][] 数组记录矩阵元素是否被访问过，当匹配不成功或者所有可能路径都被访问过则失败 class Solution { int[][] dirs = new int[][]{ {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; public boolean exist(char[][] board, String word) { if (board == null || board[0] == null || board.length == 0 || board[0].length == 0 || word == null || word.length() == 0) return false; int m = board.length, n = board[0].length; char[] chs = word.toCharArray(); boolean[][] visited = new boolean[m][n]; for (int i = 0; i = board.length || row = board[0].length || col 知识点 在 Java 中 短路运算符 指的是 && (与) 和 || (或) ，非短路运算符 指的是 & 和 | 短路运算符：顾名思义，具有短路功能 如果 && 运算符的第一个表达式为 false ，则第二个表达式就不会执行 如果 || 运算符的第一个表达式为 true， 则第二个表达式就不会执行 非短路运算符 不管第一个表达式是否可以得出最后结果，都要对第二个表达式进行判断 "}}